recorder\internal\controller\controller.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package controller

import (
	"context"
	"io"
	"strings"

	"github.com/andrescosta/goico/pkg/ioutil"
	pb "github.com/andrescosta/jobico/api/types"
	"github.com/andrescosta/jobico/recorder/internal/recorder"
	"github.com/nxadm/tail"
	"github.com/rs/zerolog"
)

type Recorder struct {
	recorder *recorder.LogRecorder
	fullpath string
}

func New(fullpath string) (*Recorder, error) {
	r, err := recorder.New(fullpath)
	if err != nil {
		return nil, err
	}
	return &Recorder{
		recorder: r,
		fullpath: fullpath,
	}, nil
}
func (s *Recorder) AddJobExecution(_ context.Context, r *pb.AddJobExecutionRequest) (*pb.AddJobExecutionReply, error) {
	if err := s.recorder.AddExecution(r.Execution); err != nil {
		return nil, err
	}
	return &pb.AddJobExecutionReply{}, nil
}
func (s *Recorder) GetJobExecutions(g *pb.GetJobExecutionsRequest, r pb.Recorder_GetJobExecutionsServer) error {
	logger := zerolog.Ctx(r.Context())
	seekInfo := &tail.SeekInfo{
		Offset: 0,
		Whence: io.SeekEnd,
	}
	if g.Lines != nil && *g.Lines > 0 {
		lines, err := ioutil.LastLines(s.fullpath, int(*g.Lines), true, true)
		if err != nil {
			logger.Warn().Msgf("error getting tail lines %s", err)
		} else {
			if len(lines) > 0 {
				if err := r.Send(&pb.GetJobExecutionsReply{
					Result: lines,
				}); err != nil {
					logger.Warn().Msgf("error sending tail lines %s", err)
				}
			}
		}
	}
	tail, err := tail.TailFile(s.fullpath, tail.Config{Follow: true, ReOpen: true, Poll: true, CompleteLines: true, Location: seekInfo})
	if err != nil {
		logger.Err(err).Msg("error tailing file")
		return err
	}
	for {
		select {
		case <-r.Context().Done():
			return nil
		case line := <-tail.Lines:
			if line != nil && strings.TrimSpace(line.Text) != "" {
				if line.Err != nil {
					logger.Err(err).Msg("error tailing file")
					return line.Err
				}
				err := r.Send(&pb.GetJobExecutionsReply{
					Result: []string{line.Text},
				})
				if err != nil {
					logger.Err(err).Msg("error sending content")
				}
			}
		}
	}
}
tools\internal\cmd\out.go:58:23: Error return value of `templatehelper.Render` is not checked (errcheck)
	templatehelper.Render(bw, usageTemplate, cmd)
	                     ^
tools\internal\cmd\out.go:66:23: Error return value of `templatehelper.Render` is not checked (errcheck)
	templatehelper.Render(bw, helpTemplate, cmd)
	                     ^
tools\internal\cmd\out.go:74:23: Error return value of `templatehelper.Render` is not checked (errcheck)
	templatehelper.Render(bw, errorTemplate, cmd)
	                     ^
ctl\internal\controller\tenant.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package controller

import (
	"context"

	"github.com/andrescosta/goico/pkg/convert"
	"github.com/andrescosta/goico/pkg/database"
	pb "github.com/andrescosta/jobico/api/types"
	"github.com/andrescosta/jobico/ctl/internal/dao"
	"google.golang.org/protobuf/proto"
)

const (
	tblTenant = "tenant"
)

type Tenant struct {
	daoCache *dao.Cache
}

func NewTenant(db *database.Database) *Tenant {
	return &Tenant{
		daoCache: dao.NewCache(db),
	}
}

func (c *Tenant) Close() {
}

func (c *Tenant) GetTenants(ctx context.Context, in *pb.GetTenantsRequest) (*pb.GetTenantsReply, error) {
	if in.ID != nil {
		t, err := c.getTenant(ctx, *in.ID)
		if err != nil {
			return nil, err
		}
		if t != nil {
			return &pb.GetTenantsReply{Tenants: []*pb.Tenant{t}}, nil
		}
		return &pb.GetTenantsReply{}, nil
	}
	ts, err := c.getTenants(ctx)
	if err != nil {
		return nil, err
	}
	return &pb.GetTenantsReply{Tenants: ts}, nil
}
func (c *Tenant) AddTenant(ctx context.Context, in *pb.AddTenantRequest) (*pb.AddTenantReply, error) {
	mydao, err := c.daoCache.GetGeneric(ctx, tblTenant, &pb.Tenant{})
	if err != nil {
		return nil, err
	}
	var m proto.Message = in.Tenant
	_, err = mydao.Add(ctx, m)
	if err != nil {
		return nil, err
	}
	return &pb.AddTenantReply{Tenant: in.Tenant}, nil
}
func (c *Tenant) getTenants(ctx context.Context) ([]*pb.Tenant, error) {
	mydao, err := c.daoCache.GetGeneric(ctx, tblTenant, &pb.Tenant{})
	if err != nil {
		return nil, err
	}
	ms, err := mydao.All(ctx)
	if err != nil {
		return nil, err
	}
	tenants := convert.Slices[proto.Message, *pb.Tenant](ms)
	return tenants, nil
}
func (c *Tenant) getTenant(ctx context.Context, id string) (*pb.Tenant, error) {
	mydao, err := c.daoCache.GetGeneric(ctx, tblTenant, &pb.Tenant{})
	if err != nil {
		return nil, err
	}
	ms, err := mydao.Get(ctx, id)
	if err != nil {
		return nil, err
	}
	if ms != nil {
		return (*ms).(*pb.Tenant), nil
	}
	return nil, nil
}
ctl\internal\controller\package.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package controller

import (
	"context"

	"github.com/andrescosta/goico/pkg/convert"
	"github.com/andrescosta/goico/pkg/database"
	pb "github.com/andrescosta/jobico/api/types"
	"github.com/andrescosta/jobico/ctl/internal/dao"
	"github.com/andrescosta/jobico/pkg/grpchelper"
	"google.golang.org/protobuf/proto"
)

const (
	tblPackage = "package"
)

type Package struct {
	daoCache         *dao.Cache
	bJobPackage      *grpchelper.GrpcBroadcaster[*pb.UpdateToPackagesStrReply, proto.Message]
	tenantController Tenant
}

func NewPackage(ctx context.Context, db *database.Database) *Package {
	return &Package{
		daoCache:    dao.NewCache(db),
		bJobPackage: grpchelper.StartBroadcaster[*pb.UpdateToPackagesStrReply, proto.Message](ctx),
	}
}
func (c *Package) Close() {
	c.bJobPackage.Stop()
}

func (c *Package) GetPackages(ctx context.Context, in *pb.GetJobPackagesRequest) (*pb.GetJobPackagesReply, error) {
	if in.ID != nil {
		p, err := c.getPackage(ctx, in.Tenant, *in.ID)
		if err != nil {
			return nil, err
		}
		if p != nil {
			return &pb.GetJobPackagesReply{Packages: []*pb.JobPackage{p}}, nil
		}
		return &pb.GetJobPackagesReply{}, nil
	}
	packages, err := c.getPackages(ctx, in.Tenant)
	if err != nil {
		return nil, err
	}
	return &pb.GetJobPackagesReply{Packages: packages}, nil
}

func (c *Package) GetAllPackages(ctx context.Context, _ *pb.GetAllJobPackagesRequest) (*pb.GetAllJobPackagesReply, error) {
	ms, err := c.tenantController.getTenants(ctx)
	if err != nil {
		return nil, err
	}
	packages := make([]*pb.JobPackage, 0)
	for _, me := range ms {
		mydao, err := c.daoCache.GetForTenant(ctx, me.ID, tblPackage, &pb.JobPackage{})
		if err != nil {
			return nil, err
		}
		ms, err := mydao.All(ctx)
		if err != nil {
			return nil, err
		}
		ps := convert.Slices[proto.Message, *pb.JobPackage](ms)
		packages = append(packages, ps...)
	}
	return &pb.GetAllJobPackagesReply{Packages: packages}, nil
}

func (c *Package) AddPackage(ctx context.Context, in *pb.AddJobPackageRequest) (*pb.AddJobPackageReply, error) {
	mydao, err := c.daoCache.GetForTenant(ctx, in.Package.Tenant, tblPackage, &pb.JobPackage{})
	if err != nil {
		return nil, err
	}
	var m proto.Message = in.Package
	_, err = mydao.Add(ctx, m)
	if err != nil {
		return nil, err
	}
	c.broadcastAdd(ctx, in.Package)
	return &pb.AddJobPackageReply{Package: in.Package}, nil
}
func (c *Package) UpdatePackage(ctx context.Context, in *pb.UpdateJobPackageRequest) (*pb.UpdateJobPackageReply, error) {
	mydao, err := c.daoCache.GetForTenant(ctx, in.Package.Tenant, tblPackage, &pb.JobPackage{})
	if err != nil {
		return nil, err
	}
	var m proto.Message = in.Package
	err = mydao.Update(ctx, m)
	if err != nil {
		return nil, err
	}
	c.broadcastUpdate(ctx, in.Package)
	return &pb.UpdateJobPackageReply{}, nil
}

func (c *Package) DeletePackage(ctx context.Context, in *pb.DeleteJobPackageRequest) (*pb.DeleteJobPackageReply, error) {
	mydao, err := c.daoCache.GetForTenant(ctx, in.Package.Tenant, tblPackage, &pb.JobPackage{})
	if err != nil {
		return nil, err
	}
	err = mydao.Delete(ctx, in.Package.ID)
	if err != nil {
		return nil, err
	}
	c.broadcastDelete(ctx, in.Package)
	return &pb.DeleteJobPackageReply{}, nil
}
func (c *Package) UpdateToPackagesStr(_ *pb.UpdateToPackagesStrRequest, r pb.Control_UpdateToPackagesStrServer) error {
	return c.bJobPackage.RcvAndDispatchUpdates(r)
}
func (c *Package) getPackages(ctx context.Context, tenant string) ([]*pb.JobPackage, error) {
	mydao, err := c.daoCache.GetForTenant(ctx, tenant, tblPackage, &pb.JobPackage{})
	if err != nil {
		return nil, err
	}
	ms, err := mydao.All(ctx)
	if err != nil {
		return nil, err
	}
	packages := convert.Slices[proto.Message, *pb.JobPackage](ms)
	return packages, nil
}
func (c *Package) getPackage(ctx context.Context, tenant string, id string) (*pb.JobPackage, error) {
	mydao, err := c.daoCache.GetForTenant(ctx, tenant, tblPackage, &pb.JobPackage{})
	if err != nil {
		return nil, err
	}
	ms, err := mydao.Get(ctx, id)
	if err != nil {
		return nil, err
	}
	if ms != nil {
		return (*ms).(*pb.JobPackage), nil
	}
	return nil, nil
}

func (c *Package) broadcastAdd(ctx context.Context, m *pb.JobPackage) {
	c.broadcast(ctx, m, pb.UpdateType_New)
}
func (c *Package) broadcastUpdate(ctx context.Context, m *pb.JobPackage) {
	c.broadcast(ctx, m, pb.UpdateType_Update)
}
func (c *Package) broadcastDelete(ctx context.Context, m *pb.JobPackage) {
	c.broadcast(ctx, m, pb.UpdateType_Delete)
}
func (c *Package) broadcast(ctx context.Context, m *pb.JobPackage, utype pb.UpdateType) {
	c.bJobPackage.Broadcast(ctx, m, utype)
}
ctl\internal\controller\environment.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package controller

import (
	"context"

	"github.com/andrescosta/goico/pkg/database"
	pb "github.com/andrescosta/jobico/api/types"
	"github.com/andrescosta/jobico/ctl/internal/dao"
	"github.com/andrescosta/jobico/pkg/grpchelper"
	"google.golang.org/protobuf/proto"
)

const (
	tblEnvironment = "environment"
	environmentID  = "environment_1"
)

type Environment struct {
	daoCache    *dao.Cache
	bEnviroment *grpchelper.GrpcBroadcaster[*pb.UpdateToEnviromentStrReply, proto.Message]
}

func NewEnvironment(ctx context.Context, db *database.Database) *Environment {
	return &Environment{
		daoCache:    dao.NewCache(db),
		bEnviroment: grpchelper.StartBroadcaster[*pb.UpdateToEnviromentStrReply, proto.Message](ctx),
	}
}
func (c *Environment) Close() {
	c.bEnviroment.Stop()
}

func (c *Environment) AddEnviroment(ctx context.Context, in *pb.AddEnviromentRequest) (*pb.AddEnviromentReply, error) {
	mydao, err := c.daoCache.GetGeneric(ctx, tblEnvironment, &pb.Environment{})
	if err != nil {
		return nil, err
	}
	in.Environment.ID = environmentID
	var m proto.Message = in.Environment
	_, err = mydao.Add(ctx, m)
	if err != nil {
		return nil, err
	}
	c.broadcastAdd(ctx, in.Environment)
	return &pb.AddEnviromentReply{Environment: in.Environment}, nil
}
func (c *Environment) UpdateEnviroment(ctx context.Context, in *pb.UpdateEnviromentRequest) (*pb.UpdateEnviromentReply, error) {
	in.Environment.ID = environmentID
	mydao, err := c.daoCache.GetGeneric(ctx, tblEnvironment, &pb.Environment{})
	if err != nil {
		return nil, err
	}
	var m proto.Message = in.Environment
	err = mydao.Update(ctx, m)
	if err != nil {
		return nil, err
	}
	c.broadcastUpdate(ctx, in.Environment)
	return &pb.UpdateEnviromentReply{}, nil
}
func (c *Environment) GetEnviroment(ctx context.Context, _ *pb.GetEnviromentRequest) (*pb.GetEnviromentReply, error) {
	mydao, err := c.daoCache.GetGeneric(ctx, tblEnvironment, &pb.Environment{})
	if err != nil {
		return nil, err
	}
	ms, err := mydao.Get(ctx, environmentID)
	if err != nil {
		return nil, err
	}
	var environment *pb.Environment
	if ms != nil {
		environment = (*ms).(*pb.Environment)
	}
	return &pb.GetEnviromentReply{Environment: environment}, nil
}
func (c *Environment) UpdateToEnviromentStr(_ *pb.UpdateToEnviromentStrRequest, r pb.Control_UpdateToEnviromentStrServer) error {
	return c.bEnviroment.RcvAndDispatchUpdates(r)
}
func (c *Environment) broadcastAdd(ctx context.Context, m *pb.Environment) {
	c.broadcast(ctx, m, pb.UpdateType_New)
}
func (c *Environment) broadcastUpdate(ctx context.Context, m *pb.Environment) {
	c.broadcast(ctx, m, pb.UpdateType_Update)
}
func (c *Environment) broadcast(ctx context.Context, m *pb.Environment, utype pb.UpdateType) {
	c.bEnviroment.Broadcast(ctx, m, utype)
}
srv\internal\queue\controller\controller.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package controller

import (
	"context"

	pb "github.com/andrescosta/jobico/api/types"
)

type Controller struct {
	store *QueueCache[*pb.QueueItem]
}

func New(ctx context.Context) (*Controller, error) {
	s, err := NewQueueCache[*pb.QueueItem](ctx)
	if err != nil {
		return nil, err
	}
	return &Controller{
		store: s,
	}, nil
}
func (s *Controller) Queue(_ context.Context, in *pb.QueueRequest) (*pb.QueueReply, error) {
	myqueue, err := s.store.GetQueue(in.Tenant, in.Queue)
	if err != nil {
		return nil, err
	}
	for _, i := range in.Items {
		if err := myqueue.Add(i); err != nil {
			return nil, err
		}
	}
	ret := pb.QueueReply{}
	return &ret, nil
}
func (s *Controller) Dequeue(_ context.Context, in *pb.DequeueRequest) (*pb.DequeueReply, error) {
	myqueue, err := s.store.GetQueue(in.Tenant, in.Queue)
	if err != nil {
		return nil, err
	}
	i, err := myqueue.Remove()
	if err != nil {
		return nil, err
	}
	var iqs []*pb.QueueItem
	if i != nil {
		iqs = append(iqs, i)
	}
	return &pb.DequeueReply{
		Items: iqs,
	}, nil
}
pkg\grpchelper\broadcaster.go:34:43: unused-parameter: parameter 'ctx' seems to be unused, consider removing or renaming it as _ (revive)
func (b *GrpcBroadcaster[T, S]) Broadcast(ctx context.Context, value S, utype pb.UpdateType) {
                                          ^
ctl\internal\dao\cache.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package dao

import (
	"context"

	"github.com/andrescosta/goico/pkg/database"
	"google.golang.org/protobuf/proto"
)

type Cache struct {
	daos map[string]*DAO[proto.Message]
	db   *database.Database
}

func NewCache(db *database.Database) *Cache {
	return &Cache{
		daos: make(map[string]*DAO[proto.Message]),
		db:   db,
	}

}
func (c *Cache) GetGeneric(ctx context.Context, entity string, message proto.Message) (*DAO[proto.Message], error) {
	return c.GetForTenant(ctx, entity, entity, message)
}
func (c *Cache) GetForTenant(ctx context.Context, tenant string, entity string, message proto.Message) (*DAO[proto.Message], error) {
	mydao, ok := c.daos[tenant]
	if !ok {
		var err error
		mydao, err = NewDAO(ctx, c.db, tenant+"/"+entity,
			&ProtoMessageMarshaler{
				prototype: message,
			})
		if err != nil {
			return nil, err
		}
		c.daos[tenant] = mydao
	}
	return mydao, nil
}
ctl\internal\dao\cache.go:20: unnecessary trailing newline (whitespace)

}
api\pkg\remote\control.go:147:20: Error return value of `grpchelper.Listen` is not checked (errcheck)
		grpchelper.Listen(ctx, s, cb)
		                 ^
api\pkg\remote\control.go:167:20: Error return value of `grpchelper.Listen` is not checked (errcheck)
		grpchelper.Listen(ctx, s, cb)
		                 ^
api\pkg\remote\repo.go:104:20: Error return value of `grpchelper.Listen` is not checked (errcheck)
		grpchelper.Listen(ctx, s, cb)
		                 ^
repo\internal\provider\repo.go:119:13: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
		pe, ok := err.(*fs.PathError)
		          ^
repo\internal\controller\controller.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package controller

import (
	"context"

	pb "github.com/andrescosta/jobico/api/types"
	"github.com/andrescosta/jobico/pkg/grpchelper"
	"github.com/andrescosta/jobico/repo/internal/provider"
	"google.golang.org/protobuf/proto"
)

type Controller struct {
	repo        *provider.FileRepo
	bJobPackage *grpchelper.GrpcBroadcaster[*pb.UpdateToFileStrReply, proto.Message]
}

func New(ctx context.Context, dir string) *Controller {
	return &Controller{
		repo:        provider.New(dir),
		bJobPackage: grpchelper.StartBroadcaster[*pb.UpdateToFileStrReply, proto.Message](ctx),
	}
}
func (s *Controller) AddFile(ctx context.Context, r *pb.AddFileRequest) (*pb.AddFileReply, error) {
	if err := s.repo.AddFile(r.TenantFile.Tenant, r.TenantFile.File.Name, int32(r.TenantFile.File.Type), r.TenantFile.File.Content); err != nil {
		return nil, err
	}
	s.bJobPackage.Broadcast(ctx, &pb.TenantFile{Tenant: r.TenantFile.Tenant, File: &pb.File{Name: r.TenantFile.File.Name, Content: r.TenantFile.File.Content}}, pb.UpdateType_New)
	return &pb.AddFileReply{}, nil
}
func (s *Controller) GetFile(_ context.Context, r *pb.GetFileRequest) (*pb.GetFileReply, error) {
	f, err := s.repo.File(r.TenantFile.Tenant, r.TenantFile.File.Name)
	if err != nil {
		return nil, err
	}
	m, err := s.repo.GetMetadataForFile(r.TenantFile.Tenant, r.TenantFile.File.Name)
	if err != nil {
		return nil, err
	}
	return &pb.GetFileReply{
		File: &pb.File{
			Content: f,
			Type:    pb.File_FileType(m.FileType),
		},
	}, nil
}
func (s *Controller) GetAllFileNames(_ context.Context, _ *pb.GetAllFileNamesRequest) (*pb.GetAllFileNamesReply, error) {
	f, err := s.repo.Files()
	if err != nil {
		return nil, err
	}
	return &pb.GetAllFileNamesReply{
		TenantFiles: f,
	}, nil
}
func (s *Controller) UpdateToFileStr(_ *pb.UpdateToFileStrRequest, r pb.Repo_UpdateToFileStrServer) error {
	return s.bJobPackage.RcvAndDispatchUpdates(r)
}
tools\internal\tapp\listeners.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package tapp

import (
	"context"
	"errors"
	"strconv"

	"github.com/andrescosta/goico/pkg/service/grpc"
	"github.com/andrescosta/goico/pkg/service/grpc/svcmeta"

	"github.com/andrescosta/goico/pkg/yamlutil"
	pb "github.com/andrescosta/jobico/api/types"
	"github.com/rivo/tview"
	healthpb "google.golang.org/grpc/health/grpc_health_v1"
)

func onFocusFileNode(_ context.Context, c *TApp, n *tview.TreeNode) {
	f := (n.GetReference().(*node)).entity.(*sFile)
	if f.file.Type == pb.File_JsonSchema {
		pageName := f.tenant + "/" + f.file.Name
		trySwitchToPage(pageName, c.mainView, c, func() (tview.Primitive, error) {
			f, err := c.repoClient.GetFile(context.Background(), f.tenant, f.file.Name)
			if err != nil {
				return nil, errors.Join(errors.New(`"Repo" service down`), err)
			}
			cv := buildTextView(string(f))
			return cv, nil
		})
	} else {
		switchToEmptyPage(c)
	}
}

func onFocusServerNode(ctx context.Context, c *TApp, n *tview.TreeNode) {
	h := (n.GetReference().(*node)).entity.(*sServerNode)
	addr := h.host.Ip + ":" + strconv.Itoa(int(h.host.Port))
	trySwitchToPage(addr, c.mainView, c, func() (tview.Primitive, error) {
		switch h.host.Type {
		case pb.Host_Undefined:
			c.debugInfo("undefined hos type")
		case pb.Host_Grpc:
			helthCheckClient := c.helthCheckClients[addr]
			infoClient, ok := c.infoClients[addr]
			if !ok {
				var err error
				infoClient, err = svcmeta.NewInfoClient(ctx, addr)
				if err != nil {
					return nil, errors.Join(errors.New(`"Server Info" service down`), err)
				}
				c.infoClients[addr] = infoClient
				helthCheckClient, err = grpc.NewHelthCheckClient(ctx, addr)
				if err != nil {
					return nil, errors.Join(errors.New(`"Healcheck" service down`), err)
				}
				c.helthCheckClients[addr] = helthCheckClient
			}
			info, err := infoClient.Info(context.Background(), &svcmeta.GrpcMetadataRequest{})
			if err != nil {
				return nil, err
			}
			s, err := helthCheckClient.Check(context.Background(), h.name)
			if err != nil {
				s = healthpb.HealthCheckResponse_NOT_SERVING
			}
			view := renderGrpcTableServer(info, s)
			return view, nil
		case pb.Host_Http, pb.Host_Headless:
			metadata, err := c.metadataClient.GetMetadata(ctx, h.name)
			if err != nil {
				return nil, err
			}
			view := renderHTTPTableServer(metadata)
			return view, nil
		default:
			return nil, nil
		}
		return nil, nil
	})
}

func onSelectedGettingJobResults(_ context.Context, ca *TApp, n *tview.TreeNode) {
	n.SetText("<< stop >>")
	nl := n.GetReference().(*node)
	nl.selected = onSelectedStopGettingJobResults
	ca.startGettingJobResults(n)
}

func onSelectedStopGettingJobResults(_ context.Context, ca *TApp, n *tview.TreeNode) {
	ca.cancelJobResultsGetter()
	nl := n.GetReference().(*node)
	n.SetText("<< start >>")
	nl.selected = onSelectedGettingJobResults
}

func onFocusJobPackageNode(_ context.Context, c *TApp, n *tview.TreeNode) {
	p := (n.GetReference().(*node)).entity.(*pb.JobPackage)
	pn := "package/" + p.Tenant + "/" + p.ID
	trySwitchToPage(pn, c.mainView, c, func() (tview.Primitive, error) {
		pkg, err := c.controlClient.GetPackage(context.Background(), p.Tenant, &p.ID)
		if err != nil {
			return nil, errors.Join(errors.New(`"Ctl" service down`), err)
		}
		yaml, err := yamlutil.Marshal(pkg[0])
		if err != nil {
			return nil, errors.Join(errors.New(`package cannot displayed`), err)
		}
		textView := buildTextView(syntaxHighlightYaml(*yaml))
		return textView, nil
	})
}
tools\internal\tapp\renders.go:1: File is not `gci`-ed with --skip-generated -s standard -s default (gci)
package tapp

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/andrescosta/goico/pkg/service/grpc/svcmeta"
	"github.com/gdamore/tcell/v2"
	"github.com/rivo/tview"
	healthpb "google.golang.org/grpc/health/grpc_health_v1"
)

func (c *TApp) renderUI(ctx context.Context) *tview.Pages {
	// sets the main pages
	pages := tview.NewPages()
	c.mainView = tview.NewPages()
	c.mainView.SetBorderPadding(0, 0, 0, 0)
	c.mainView.SetBorder(true)
	c.mainView.AddPage(emptyPage, buildTextView(""), true, true)
	menu := c.renderSideMenu(ctx)
	c.status = newTextView("")
	c.status.SetTextAlign(tview.AlignCenter)
	helpTxt := "<Esc> - To Exit | <Tab> to switch views | <Arrows> to navigate"
	if c.debug {
		helpTxt = fmt.Sprintf("%s %s", helpTxt, "| <Ctrl-D> for debug info | <Ctrl-P> To stop streaming")
	}
	f := tview.NewFlex().
		AddItem(tview.NewFlex().SetDirection(tview.FlexRow).
			AddItem(c.status, 0, 1, false).
			AddItem(nil, 0, 1, false).
			AddItem(newTextView(helpTxt), 0, 1, false), 0, 1, false)
	grid := tview.NewGrid().
		SetRows(3, 0, 3).
		SetColumns(25, 30).
		SetBorders(true).
		AddItem(newTextView("Jobico Dashboard"), 0, 0, 1, 4, 0, 0, false).
		AddItem(f, 2, 0, 1, 4, 0, 0, false)
	// Layout for screens narrower than 100 cells (menu and side bar are hidden).
	grid.AddItem(menu, 1, 0, 1, 1, 0, 0, true).
		AddItem(c.mainView, 1, 1, 1, 3, 0, 0, false)
	// Layout for screens wider than 100 cells.
	grid.AddItem(menu, 1, 0, 1, 0, 0, 40, true).
		AddItem(c.mainView, 1, 1, 0, 0, 0, 160, false)
	quitModal := tview.NewModal().SetText("Do you want to quit the application?").
		AddButtons([]string{"Quit", "Cancel"}).
		SetDoneFunc(func(buttonIndex int, buttonLabel string) {
			if buttonLabel == "Quit" {
				c.app.Stop()
			} else {
				pages.HidePage(quitPageModal)
				c.app.SetFocus(menu)
			}
		})
	c.debugTextView = buildTextView("")
	c.debugTextView.SetWordWrap(true)
	c.debugTextView.SetWrap(true)
	fmt.Fprintf(c.debugTextView, "Debug information for process: %d\n", os.Getppid())
	c.debugTextView.SetBorder(true)
	pages.AddPage(mainPage, grid, true, true)
	pages.AddPage(debugPage, c.debugTextView, true, false)
	// It is important that the last page is always the quit page, so
	// it can appears on top of the others without the need to hide them
	pages.AddPage(quitPageModal, newModal(
		quitModal, 40, 10), true, false)
	c.app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
		fp, _ := pages.GetFrontPage()
		//exhaustive:ignore
		switch event.Key() {
		case tcell.KeyTAB:
			if fp == mainPage && !quitModal.HasFocus() {
				if menu.HasFocus() {
					c.app.SetFocus(c.mainView)
				} else {
					c.app.SetFocus(menu)
				}
			}
			return nil
		case tcell.KeyEscape, tcell.KeyCtrlC:
			pages.ShowPage(quitPageModal)
			return nil
		case tcell.KeyCtrlD:
			if fp == debugPage {
				pages.SwitchToPage(mainPage)
				c.app.SetFocus(menu)
			} else {
				pages.SwitchToPage(debugPage)
			}
			return nil
		case tcell.KeyCtrlP:
			if c.debug {
				c.stopStreamingUpdates()
			}
		case tcell.KeyCtrlU:
			if c.debug {
				c.execProtected(func() { panic("testing panic") })
			}
		default:
			return event
		}
		return event
	})
	return pages
}

func (c *TApp) renderSideMenu(ctx context.Context) *tview.TreeView {
	e, err := c.controlClient.GetEnviroment(ctx)
	if err != nil {
		panic(err)
	}
	ep, err := c.controlClient.GetAllPackages(ctx)
	if err != nil {
		panic(err)
	}
	fs, err := c.repoClient.GetAllFileNames(ctx)
	if err != nil {
		panic(err)
	}
	r := renderNode(rootNode(e, ep, fs))
	c.root = r
	menu := tview.NewTreeView()
	menu.SetRoot(r)
	menu.SetCurrentNode(r)
	menu.SetBorder(true)
	var m = map[bool]string{
		true:  iconExpanded,
		false: iconContracted,
	}
	menu.SetSelectedFunc(func(n *tview.TreeNode) {
		original := n.GetReference().(*node)
		if len(original.children) > 0 {
			if !original.expanded {
				if n.IsExpanded() {
					c.refreshRootNode(ctx, n)
				}
				pref := m[n.IsExpanded()]
				npref := m[!n.IsExpanded()]
				ns, e := strings.CutPrefix(n.GetText(), pref)
				if e {
					n.SetText(npref + ns)
					n.SetExpanded(!n.IsExpanded())
				}
			}
		} else if original.selected != nil {
			c.execProtected(func() { original.selected(ctx, c, n) })
		}
	})
	// This function simulates the focus and blur event handlers for the tree's nodes
	menu.SetChangedFunc(func(n *tview.TreeNode) {
		if c.lastNode != nil {
			nl := c.lastNode.GetReference().(*node)
			if nl.blur != nil {
				c.execProtected(func() { nl.blur(ctx, c, c.lastNode, n) })
			}
		}
		ref := n.GetReference().(*node)
		if ref.focus != nil {
			c.execProtected(func() { ref.focus(ctx, c, n) })
		}
		c.lastNode = n
	})
	return menu
}
func renderNode(target *node) *tview.TreeNode {
	if target.color == tcell.ColorDefault {
		if len(target.children) > 0 {
			if !target.expanded {
				target.text = fmt.Sprintf("%s %s", iconContracted, target.text)
			}
			target.color = tcell.ColorGreen
		} else {
			target.color = tcell.ColorWhite
		}
	}
	node := tview.NewTreeNode(target.text).
		SetExpanded(target.expanded).
		SetReference(target).
		SetColor(target.color)
	for _, child := range target.children {
		node.AddChild(renderNode(child))
	}
	return node
}

func renderHTTPTableServer(info map[string]string) *tview.Table {
	table := tview.NewTable().
		SetBorders(true)
	table.SetCell(0, 0,
		tview.NewTableCell("Status").
			SetAlign(tview.AlignCenter))
	status := "Unknown"
	table.SetCell(0, 1,
		tview.NewTableCell(status).
			SetAlign(tview.AlignCenter))
	ix := 0
	for k, v := range info {
		table.SetCell(ix+1, 0,
			tview.NewTableCell(k).
				SetAlign(tview.AlignCenter))
		table.SetCell(ix+1, 1,
			tview.NewTableCell(v).
				SetAlign(tview.AlignCenter))
		ix++
	}
	return table
}

func renderGrpcTableServer(infos []*svcmeta.GrpcServerMetadata, s healthpb.HealthCheckResponse_ServingStatus) *tview.Table {
	table := tview.NewTable().
		SetBorders(true)
	table.SetCell(0, 0,
		tview.NewTableCell("Status").
			SetAlign(tview.AlignCenter))
	status := "Not ok"
	if s == healthpb.HealthCheckResponse_SERVING {
		status = "Ok"
	}
	table.SetCell(0, 1,
		tview.NewTableCell(status).
			SetAlign(tview.AlignCenter))
	for ix, info := range infos {
		table.SetCell(ix+1, 0,
			tview.NewTableCell(info.Key).
				SetAlign(tview.AlignCenter))
		table.SetCell(ix+1, 1,
			tview.NewTableCell(info.Value).
				SetAlign(tview.AlignCenter))
	}
	return table
}
tools\internal\tapp\tapp.go:221:1: receiver-naming: receiver name ca should be consistent with previous receiver name c for TApp (revive)
func (ca *TApp) startGettingJobResults(n *tview.TreeNode) {
	var textView *tview.TextView
	lines := int32(5)
	if ca.mainView.HasPage("results") {
		ca.mainView.SwitchToPage("results")
		_, fp := ca.mainView.GetFrontPage()
		textView = fp.(*tview.TextView)
		lines = 0
	} else {
		textView = tview.NewTextView().
			SetTextAlign(tview.AlignLeft).
			SetScrollable(true).
			SetWordWrap(false).
			SetWrap(false).
			SetMaxLines(100)
		ca.mainView.AddAndSwitchToPage("results", textView, true)
	}
	ch := make(chan string)
	var ctxJobResultsGetter context.Context
	ctxJobResultsGetter, ca.cancelJobResultsGetter = context.WithCancel(context.Background())
	go func(mc <-chan string) {
		for {
			select {
			case <-ctxJobResultsGetter.Done():
				ca.debugInfoFromGoRoutine("collector context is done. stopping results collector ")
				return
			case l, ok := <-mc:
				if ok {
					ca.app.QueueUpdateDraw(func() {
						fmt.Fprintln(textView, l)
					})
				} else {
					ca.debugInfoFromGoRoutine("collector channel is closed. stopping results collector")
					return
				}
			}
		}
	}(ch)
	go func() {
		defer close(ch)
		err := ca.recorderClient.StreamJobExecutions(ctxJobResultsGetter, "", lines, ch)
		if err != nil {
			ca.debugErrorFromGoRoutine(err)
			ca.showErrorStr("Error getting results", 3*time.Second)
			ca.app.QueueUpdateDraw(func() {
				onSelectedStopGettingJobResults(ctxJobResultsGetter, ca, n)
				disableTreeNode(n)
			})
		}
		ca.debugInfoFromGoRoutine("job execution call returned. stopping results collector")
	}()
}
tools\internal\tapp\tapp.go:82:16: ST1016: methods on the same type should have the same receiver name (seen 18x "c", 1x "ca") (stylecheck)
func (c *TApp) DebugOn() {
               ^
