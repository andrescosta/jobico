package cli

import (
	"context"
	"flag"
	"fmt"
	"os"

	"github.com/andrescosta/goico/pkg/service"
	"github.com/andrescosta/jobico/internal/api/client"
)

var cmdRecorder = &command{
	name:      "recorder",
	usageLine: "cli recorder <tenant> [-lines <NM>]",
	short:     "display real-time job output",
	long: `
The Recorder command streams real-time information generated by the Jobs of the provided tenant. 
Using the '-lines <NM>' flag outputs the last NM lines produced by the Jobs for the latest 
executions.`,
}

var cmdRecorderflagLines *int

func initRecorder() {
	cmdRecorder.flag = *flag.NewFlagSet("recorder", flag.ContinueOnError)
	cmdRecorderflagLines = cmdRecorder.flag.Int("lines", 0, "")
	cmdRecorder.flag.Usage = func() {}
	cmdRecorder.run = runRecorder
}

func runRecorder(ctx context.Context, cmd *command, d service.GrpcDialer, _ []string) {
	ch := make(chan string)
	go func(mc <-chan string) {
		for {
			select {
			case <-ctx.Done():
				return
			case l := <-mc:
				fmt.Println(l)
			}
		}
	}(ch)
	fmt.Printf("getting results at proc: %d \n", os.Getpid())
	client, err := client.NewRecorder(ctx, d)
	if err != nil {
		printError(os.Stderr, cmd, err)
		return
	}
	if err := client.StreamJobExecutions(ctx, int32(*cmdRecorderflagLines), ch); err != nil {
		printError(os.Stderr, cmd, err)
		return
	}
	fmt.Println("command stoped.")
}
