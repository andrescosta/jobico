package cli

import (
	"context"
	"flag"
	"fmt"
	"os"

	"github.com/andrescosta/goico/pkg/service"
	"github.com/andrescosta/jobico/internal/api/client"
)

func newRecorder() *command {
	cmdRecorder := &command{
		name:      "recorder",
		usageLine: "cli recorder <tenant> [-lines <NM>]",
		short:     "display real-time job output",
		long: `
	The Recorder command streams real-time information generated by the Jobs of the provided tenant. 
	Using the '-lines <NM>' flag outputs the last NM lines produced by the Jobs for the latest 
	executions.`,
	}
	cmdRecorder.flag = *flag.NewFlagSet("recorder", flag.ContinueOnError)
	_ = cmdRecorder.flag.Int("lines", 0, "")
	cmdRecorder.flag.Usage = func() {}
	cmdRecorder.run = runRecorder
	return cmdRecorder
}

func runRecorder(ctx context.Context, cmd *command, d service.GrpcDialer, _ []string) {
	ch := make(chan string)
	go func(mc <-chan string) {
		for {
			select {
			case <-ctx.Done():
				return
			case l := <-mc:
				fmt.Println(l)
			}
		}
	}(ch)
	fmt.Printf("getting results at proc: %d \n", os.Getpid())
	client, err := client.NewRecorder(ctx, d)
	if err != nil {
		printError(os.Stderr, cmd, err)
		return
	}
	lines, _ := cmd.flag.Lookup("lines").Value.(flag.Getter).Get().(int)
	if err := client.StreamJobExecutions(ctx, int32(lines), ch); err != nil {
		printError(os.Stderr, cmd, err)
		return
	}
	fmt.Println("command stoped.")
}
