# Jobico

## Introduction

Welcome to Jobico â€“ An Experimental, Multi-Tenancy asynchronous computing Platform!

Jobico is a Go project designed for experimental development, with a focus on exploring asynchronous computing using WebAssembly (WASM) in a multi-tenancy environment. It prioritizes flexibility and customization, allowing tenants to define events, validate incoming data using JSON Schema, and execute custom programs in any WASM-compatible language.

## Key Characteristics

- **Exploratory Nature**: Jobico serves as an exploratory project, providing a platform for investigating innovative approaches to asynchronous computing technologies.

- **Multi-Tenancy Focus**: Jobico's architecture is specifically designed to facilitate multi-tenancy, enabling the simultaneous operation of multiple isolated tenants on the platform.

- **Event Definition with JSON Schema**: Tenants can define events through JSON Schema, allowing for structured and dynamic event handling. Incoming requests undergo validation against the specified schema.

- **WASM-Compatible Language Support**: Jobico offers support for custom program creation in any WASM-compatible language, fostering flexibility and diversity in the execution of jobs.
- 

# Architecture
![alt](docs/img/Jobico.svg?)

## Components

### Listener
The **Listener** component serves as the entry point for external events, providing a REST API that functions as a webhook. Its primary responsibilities include receiving events, validating them against pre-defined JSON schemas, and subsequently enqueueing them for further processing. This component acts as the bridge between external sources triggering events and the internal processing pipeline.

### Queue
The **Queue** component acts as a chronological buffer for events, temporarily storing them until they can be processed by the Job Executors. Events are maintained in the queue in the order they are received, ensuring a sequential flow of processing. This component plays a crucial role in decoupling the event reception from the actual event processing, allowing for scalability and efficient handling of bursts of incoming events.

### Job Executors
**Job Executors** are responsible for consuming events from the Queue and providing a controlled environment for the execution of WebAssembly (WASM) programs that process these events. This component manages the execution context, ensuring isolation and security for running custom WASM programs written by tenants. It plays a key role in the dynamic and scalable execution of programmed jobs in response to events.

### Control Service
The **Control Service** is a centralized hub where Job definitions are stored and can be queried by other components in the system. It acts as the authoritative source for managing job configurations, allowing dynamic adjustments to the processing logic without interrupting the overall system operation. This service facilitates coordination and control over the execution of jobs across the entire platform.

### Job Repository
The **Job Repository** serves as a storage facility for WebAssembly (WASM) programs and JSON schema files. It provides a dedicated API for storing and retrieving these essential files, ensuring accessibility for the Job Executors and enabling tenants to manage their custom program logic efficiently. This component acts as a repository for the building blocks required for event processing.

### Executions Recorder
The **Executions Recorder** is a service designed to capture and store log information generated by the Job Executors during the execution of jobs. This component acts as a centralized logging system, allowing for post-execution analysis, troubleshooting, and performance monitoring. The recorded information can be queried using both the Command Line Interface (CLI) and Dashboard tools, providing visibility into the historical execution details of jobs.

### Command Line Tool
The **Command Line Tool** serves as the primary management interface, providing a comprehensive set of commands to interact with the Jobico platform. This tool provides commands to deploy job definitions, upload associated WASM and JSON schema files, and query the Executions Recorder for log information.

### Dashboard
The **Dashboard** is a terminal-based application designed for visualizing Job definitions and execution information. The Dashboard provides a user-friendly experience to monitor and analyze the status of their jobs. 

# Job Definition

Job Definition is a fundamental concept within the Jobico platform, representing the structured description of how a job will be validated, executed, and how its results will be handled. Jobs are specified using YAML, providing a clear and human-readable format to articulate the job's configuration and behavior.

### Anatomy of a Job Definition YAML:
A Job Definition YAML file includes various attributes that define the job's characteristics:

#### `name`

- **Description:** A friendly name for the job, used for identification and management.

- **Example:**

```yaml
name: My Job
```

#### `id`

- **Description:** The "id" attribute represents the unique identifier for the job. It serves as a distinct reference to identify and manage the job within the Jobico platform.

- **Example:**

  ```yaml
  id: my-job
  ```

#### `tenant`

- **Description:** The "tenant" attribute represents the ID of the tenant associated with the job. It ensures that the job is attributed to a specific tenant within the multi-tenancy architecture of Jobico.

- **Example:**

  ```yaml
  tenant: tenant-1
  ```

#### `queues`

- **Description:** The "queues" section describes the queues associated with the job. This section allows for future expansion where queue environments and capabilities can be defined.

  - `queues.id`: ID of the queue.
  - `queues.name`: Friendly name of the queue.

- **Example:**

  ```yaml
     queues:
       - id: default-queue
         name: Default to all events
  ```

#### `jobs`

- **Description:** The "jobs" section is where the events are defined and how they will be validated and processed.

  - `jobs.event`: An event definition.
  - `jobs.event.name`: Friendly name for the event.
  - `jobs.event.id`: ID for the event, used by the REST API and executors to determine the schema and WASM file.
  - `jobs.event.datatype`: Specifies the data type of the event. "0" represents JSON.

  - **`jobs.event.schema`: Schema file definition:**

    - `jobs.event.schema.id`: ID of the schema file.
    - `jobs.event.schema.name`: Name of the schema file.
    - `jobs.event.schema.schemaref`: Reference used to retrieve the file from the repository.

  - `jobs.event.supplierqueue`: Specifies the ID of the queue where this event will be published.
  - `jobs.event.runtime`: ID of the runtime that will process this event.
  - `jobs.event.result`: Specifies how the result of the execution will be treated (Under Construction).

- **Example:**

  ```yaml
  jobs:
    - event:
        name: User's registration
        id: user-registration
        datatype: 0
        schema:
           id: user-registration-schema
           name: Registration schema
           schemaref: /schemas/user-registration-schema.json
        supplierqueue: 1
        runtime: 1
  ```

  In this example, a job is defined for processing "user-registration" events with the associated schema and runtime details.

#### `runtimes`

- **Description:** The "runtimes" section specifies the runtimes available to process the events.

  - `runtimes.id`: ID of the runtime, used to reference a specific runtime.
  - `runtimes.name`: Friendly name.
  - `runtimes.moduleref`: Reference used to retrieve the file from the repository.
  - `runtimes.mainfuncname`: Not used at the moment.
  - `runtimes.type`: "0" represents WASM as the runtime type.

- **Example:**

  ```yaml
  runtimes:
    - id: wasm-runtime-user-reg-v1
      name: Wasm runtime for User reg.
      moduleref: /runtimes/wasm-runtime.wasm
      mainfuncname: event
      type: 0
  ```

  In this example, a runtime named "wasm-runtime" is defined with the associated WASM file and runtime type.

These attributes collectively form a comprehensive YAML file, capturing the essential details for defining and deploying jobs within the Jobico platform. 

### Example

```yaml
name: Demo JOB
id: go-demo-job
tenant: demogo
queues:
  - id: queue-default
    name: Q.Default
jobs:
  - event:
      name: Greet event
      id: evgo
      datatype: 0
      schema:
        id: greet-event-schema
        name: Greet's schema
        schemaref: greet-schema-go.json
      supplierqueue: queue-default
      runtime: greet-event-go
runtimes:
  - id: greet-event-go
    name: Greet Evenent Func
    moduleref: greet-wasm-go.wasm
    mainfuncname: event
    type: 0
```

## Jobicolet

### What is a Jobicolet?

A **Jobicolet** is a specialized WebAssembly (WASM) program designed to process an event and generate a result within the Jobico platform. It represents the executable logic that is dynamically loaded and executed by the Job Executors when handling specific 

### Key Characteristics:

1. **WASM Execution:**
   - A Jobicolet is implemented as a WebAssembly module, allowing it to be written in any programming language that compiles to WebAssembly. This flexibility empowers users to express their event processing logic in a language of their choice.

2. **Event Processing:**
   - The primary function of a Jobicolet is to process events. It takes as input the event data, performs the specified logic defined within the WASM module, and produces a result based on the defined processing rules.

3. **Result Generation:**
   - Upon processing an event, a Jobicolet generates a result. The nature of the result depends on the specific logic implemented in the WASM module. It could be a computation outcome, a transformed dataset, or any other relevant output.

4. **Language Agnostic:**
   - Jobicolets are language-agnostic in the sense that they can be written in any programming language that supports compilation to WebAssembly. This feature provides developers with the freedom to choose a language that aligns with their expertise and the requirements of their event processing tasks.

### Benefits:

- **Flexibility:**
  - The language-agnostic nature of Jobicolets provides developers with flexibility, allowing them to choose the most suitable programming language for expressing their event processing logic.

- **Scalability:**
  - As Jobicolets are executed within the scalable and isolated environment of Job Executors, the platform can efficiently scale to handle a large number of concurrent event processing tasks.

- **Interoperability:**
  - Jobicolets can interact with other components within the Jobico platform, facilitating seamless integration with queues, event definitions, and runtime environments.

A Jobicolet, at its core, represents the embodiment of programmable and scalable event processing within the Jobico platform, offering developers the freedom to innovate using the power of WebAssembly.

## Getting Started

### Rust

### Prerequisites:

1. **Install Rust:**
   - Download and install Rust from [https://www.rust-lang.org/](https://www.rust-lang.org/).

2. **Install wasm-pack:**
   - After installing Rust, install `wasm-pack` by running the following command:

     ```bash
     cargo install wasm-pack
     ```

3. **Clone the Examples Repository:**
   - Clone the jobicolet-examples repository from GitHub using the following command:

     ```bash
     git clone https://github.com/andrescosta/jobicolet-examples.git
     ```

### Build the Rust Example:

1. **Navigate to the Rust Example Directory:**
   - Change your working directory to the location of the Rust example in the jobicolet-examples repository:

     ```bash
     cd jobicolet-examples/rust/greet
     ```

2. **Compile the Example using Cargo:**
   - Use the following command to compile the Rust program (`greet.rs`) using Cargo:

     ```bash
     cargo build --release --target wasm32-unknown-unknown
     ```

   This command instructs Cargo to build the Rust program in release mode (`--release`) for the WebAssembly target (`--target wasm32-unknown-unknown`).

3. **Verify the Output:**
   - After a successful build, you should find the compiled WebAssembly module in the `target/wasm32-unknown-unknown/release/` directory. The file will be named `greet.wasm`.

4. **Upload the WASM file to Jobico:**
   - After compiling the file, it must be uploaded to Jobico using this command:

    ```bash
     cli upload wasm demorust greet-wasm-rust.wasm target\wasm32-unknown-unknown\release\greet.wasm
     ```
5. **Upload the schema file to Jobico:**
   - This command will upload the schema file to validate the event:

    ```bash
     cli upload json demorust  greet-schema-rust.json schema.json
     ```
6. **Deploy the job:**
   - This command will deploy the Job:

    ```bash
     cli deploy job-rust-greet.yml
     ```
7. **Start streaming results:**
   - This command will start streaming results from the Recorder component:

    ```bash
     cli recorder
     ```
8. **Send an event:**
   - This command will send an event:

    ```bash
          curl --request POST \ 
          --url http://localhost:8080/events/demogo/evgo \  
          --header 'content-type: application/json' \
          --data '{"data": [{"firstName": "Andres","lastName": "C"}]}'
     ```
   - The command started in point 7 should be displaying the log generated by the event.

### Summary of Commands:

```bash
# Step 1: Install Rust
# Step 2: Clone the Examples Repository
git clone https://github.com/andrescosta/jobicolet-examples.git

# Step 3: Navigate to the Rust Example Directory
cd jobicolet-examples/rust/greet

# Step 4: Compile the Example using Cargo
cargo build --release --target wasm32-unknown-unknown
```

### Tinygo

### Prerequisites:

1. **Install TinyGo:**
   - Download and install TinyGo from [https://tinygo.org/](https://tinygo.org/).

2. **Clone the Examples Repository:**
   - Clone the jobicolet-examples repository from GitHub using the following command:

     ```bash
     git clone https://github.com/andrescosta/jobicolet-examples.git
     ```

3. ** The Jobico platform is up and running **
   - The Docker section taches you how to start Jobico

### Build the Go Example:

1. **Navigate to the Go Example Directory:**
   - Change your working directory to the location of the Go example in the jobicolet-examples repository:

     ```bash
     cd jobicolet-examples/go/greet
     ```

2. **Compile the Example using TinyGo:**
   - Use the following command to compile the greet.go example using TinyGo:

     ```bash
     tinygo build -target wasi greet.go
     ```

   This command instructs TinyGo to build the Go program (`greet.go`) for the WebAssembly System Interface (WASI) target.

3. **Verify the Output:**
   - After a successful build, you should see an executable file named `greet.wasm` in the same directory.

4. **Upload the WASM file to Jobico:**
   - After compiling the file, it must be uploaded to Jobico using this command:

    ```bash
     cli upload wasm demogo greet-wasm-go.wasm greet.wasm
     ```
5. **Upload the schema file to Jobico:**
   - This command will upload the schema file to validate the event:

    ```bash
     cli upload json demogo greet-schema-go.json schema.json
     ```
6. **Deploy the job:**
   - This command will deploy the Job:

    ```bash
     cli deploy job-go-greet.yml
     ```
7. **Start streaming results:**
   - This command will start streaming results from the Recorder component:

    ```bash
     cli recorder
     ```
8. **Send an event:**
   - This command will send an event:

    ```bash
          curl --request POST \ 
          --url http://localhost:8080/events/demogo/evgo \  
          --header 'content-type: application/json' \
          --data '{"data": [{"firstName": "Andres","lastName": "C"}]}'
     ```
   - The command started in point 7 should be displaying the log generated by the event.

# Tools

## Jobico Command Line Tool

### Overview:

The **Jobico Command Line Tool** is a management interface designed to facilitate the deployment, rollback, or redeployment of jobs within the Jobico platform. It offers a range of commands for uploading WebAssembly (WASM) and schema files, as well as streaming information from the Executions Recorder. This tool is an indispensable component for administrators and tenants alike, providing a streamlined and efficient way to interact with the platform.

### Key Features:

1. **Deployment Commands:**
   - **Deploy:**
     - The `deploy` command is employed to add a job definition to the Jobico platform.If the `-update` flag is provided and the job has already been deployed, the command will redeploy it.
 
     ```bash
     jobico deploy [-update] my-job-definition.yaml
     ```

   - **Rollback:**
     - The `rollback` command allows for the rollback of a deployed job to a previous state. It's a useful feature for reverting to a stable configuration in case of issues. The executor associated with the JOB are stopped.

     ```bash
     jobico rollback my-job-definition.yaml
     ```

2. **File Upload Commands:**
   - **Upload WASM:**
     - The `upload wasm` command enables the upload of a WebAssembly file to the Job Repository. This file can then be referenced by Jobicolets during deployment.

     ```bash
     jobico upload wasm <tenant id> <file id> <my-job-logic.wasm>
     ```

   - **Upload Schema:**
     - The `upload json` command allows the upload of JSON schema files to the Job Repository. These files define the structure of events processed by the platform.

     ```bash
     jobico upload json <tenant id> <file id> <my-job-logic.json>
     ```

3. **Streaming Information:**
   - **Stream from Recorder:**
     - The `recorder` command allows users to stream information from the Executions Recorder. This feature is valuable for real-time monitoring and analysis of job executions. Using the '-lines <NM>' flag outputs the last NM lines produced by the Jobs for the latest executions.

     ```bash
     jobico recorder [-lines NM]
     ```
4. **Information Commands:**
   - **Deployments**
     -  The `show deploy` command prints information about a Job Definition deployed previously. It offers details on the configuration, queues, runtims, and associated schema of a deployed job. 

     ```bash
     jobico show deploy <tenant id> <definition id>
     ```
   - **Enviroment**
     -  The `show env` command prints information about the nodes that composed a Jobico's cluster. This optionand the information provided is not used by the platform at this moment. 

     ```bash
     jobico show env
     ```

#### Deploying a Job:

```bash
jobico deploy job-config.yaml 
```

This command deploys a job named "my-job-definition" with the specified configuration, WebAssembly logic, and event schema.

#### Uploading a WASM File:

```bash
jobico upload wasm my-job-logic-v2.wasm my-job-logic-v2.wasm
```

This command uploads a new version of the WebAssembly logic file to the Job Repository.

#### Streaming Information from Recorder:

```bash
jobico recorder [--lines NM]
```

This command streams log information from the Executions Recorder for the specified job.

## Dashboard - Terminal GUI

### Overview:

The **Jobico Dashboard** is a terminal-based graphical user interface (GUI) designed to offer an interactive and visual representation of the Jobico platform. This GUI allows users to seamlessly visualize deployed jobs, explore files in the repository, and stream real-time results produced by executed jobs, all within the convenience of the terminal.

### Key Features:

1. **Visualizing Deployed Jobs:**
   - The Dashboard GUI presents a visual overview of deployed jobs, displaying relevant details such as job names, configurations, and status indicators. Users can easily navigate and interact with job-related information.

2. **Browsing Repository Files:**
   - Users can explore files stored in the Job Repository through an intuitive graphical interface. This includes the ability to inspect WebAssembly (WASM) files, JSON schema definitions, and other artifacts crucial for job execution.

3. **Streaming Job Results:**
   - The Dashboard supports real-time streaming of results produced by executed jobs. The GUI provides a dynamic display of outcomes, offering users immediate visibility into the status and performance of their jobs.

### Example Dashboard Commands:

#### Launching the Dashboard:

```bash
dashboard [-debug] [-sync]
```

Executing this command launches the Dashboard GUI, initiating an interactive environment for users to visually explore deployed jobs and related information.

# Goico: The Jobico Framework

## Overview:

**Goico** is a specialized framework  crafted to support the development and evolution of Jobico. 

## Key Features:

### 1. Service Creation and API Exposure:

Goico simplifies the development of microservices within the Jobico ecosystem. It supports creating services that expose REST or gRPC APIs, fostering a modular and scalable architecture. 

### 2. WASM Runtime Based on WAZERO:

A core strength of Goico lies in its WebAssembly (WASM) runtime, built on the robust foundation of WAZERO. This runtime facilitates the execution of custom logic written in any WASM-supported programming language. 

### 3. Key/Value Embedded Database:

Goico integrates an embedded database based on [BBolt](https://github.com/etcd-io/bbolt), offering a key/value store for data management. This embedded database serves as the backbone for storing critical information, supporting the reliable and fast retrieval of data essential for the operation of Jobico.

### 4. Streaming Capabilities for Database Updates:

Goico provides streaming capabilities for database updates based on Grpc. This feature enables real-time monitoring and reaction to changes within the embedded database, facilitating dynamic adjustments, and enhancing the responsiveness of Jobico to evolving requirements.

### Docker

### Prerequisites:

1. Ensure Docker and Docker Compose are installed on your local machine.

### Steps:

1. **Navigate to the `/compose` directory:**

    ```bash
    cd compose
    ```

2. **Run Docker Compose:**

    ```bash
    docker compose up
    ```

    This command will start the Docker Compose stack based on the configuration defined in the `compose.yml` file.

3. **Verify Listener on Port 8080:**

    Once the Docker Compose stack is up and running, you can verify that the Listener is running on port 8080 by making a request. You can use a tool like `curl` or a web browser.

    - Using `curl`:

        ```bash
        curl http://localhost:8080
        ```

    - If using a web browser, navigate to `http://localhost:8080` in your browser.

4. **Stop and Cleanup:**

    When you are done testing, you can stop the Docker Compose stack using:

    ```bash
    docker compose down
    ```

    This will stop and remove the containers defined in the `compose.yml` file.

### Notes:

- Ensure that your `docker-compose.yml` file is configured properly with the necessary services, networks, and volumes.
- Adjust the commands based on the specific configurations and requirements of your Jobico project.

This set of steps assumes a basic configuration, and you may need to modify the Docker Compose file and commands based on your specific project structure and dependencies.

## Stack

Golang
Zerolog
Wazero
GRPC
BBolt
Tview: https://github.com/rivo/tview



## Roadmap (in no particular order)

### Short Term

#### WASM runtime
#### Testing

### Long Term
#### High Availability
#### Scalability/Performance
#### Security 
- AuthN
- AuthZ
- Encrytion at rest and in transit

### Acknowledgements

## Support and Contact

For questions, feedback, or assistance, reach out to us at [jobicowasm@gmail.com].
